<?php


/**
 * Implementation of hook_form_BASE_FORM_ID_alter().
 */
function thechurch_comments_form_comment_form_alter(&$form, &$form_state, $form_id) {
	//drupal_set_message('<pre>'.print_r($form, true).'</pre>');
	// Add the Ajax Submit Function
	$form['actions']['submit']['#ajax'] = array(
		'callback' => 'thechurch_comments_ajax_callback',
		'progress' => false,
	);
	
}

/**
 * Implementation of hook_form_BASE_FORM_ID_alter().
 */
function thechurch_comments_form_comment_confirm_delete_alter(&$form, &$form_state, $form_id) {
	// drupal_set_message('<pre>'.print_r($form, true).'</pre>');
	$form['description']['#markup'] = t('This action cannot be undone.');
	// Add the Ajax Submit Function
	$form['actions']['submit']['#ajax'] = array(
		'callback' => 'thechurch_comments_ajax_delete',
		'progress' => false,
	);
	
	// Get the Comment
	$comment = $form['#comment'];
	
	// Give the Comment a Proper, Numerical ID
	$form['#id'] = 'comment-'.$comment->cid.'-confirm-delete';
	$form['#attributes']['class'][] = 'confirm-delete';
	
}

/**
 * Comments Ajax Callback.
 */
function thechurch_comments_ajax_callback($form, $form_state) {
	
	// Get rid of all of the messages that have been set
	drupal_get_messages();

	// Get the comment & node objects
	$comment = $form_state['comment'];
	$comment = comment_load($comment->cid);
	$node = $form['#node'];
	$node = node_load($node->nid);
	
	// Put all of the Ajax Commands into an array
	$commands = array();
	
	// Make sure that comment was actually loaded before proceeding. 
	if ($comment->cid && $form_state['executed']) {
	
		// Generate the Array for Drupal Render
		$comment_build = comment_view($comment, $node);
	
		// Render the Array
		$html = drupal_render($comment_build);
	
		// Place the comment above the form
		$commands[] = ajax_command_before("#node-$node->nid div.comment-form", '<div class="new-comment">'.$html.'</div>');
	
		// Remove the text in the text field
		$commands[] = ajax_command_invoke("#node-$node->nid .comment-form textarea", 'val', array(''));
	
		// Reset the text area back to it's original height
		$commands[] = ajax_command_css("#node-$node->nid .comment-form textarea", array('height' => '32px'));
		
		
	}
	
	// Reset the textarea back to it's original color
	$commands[] = ajax_command_invoke("#node-$node->nid .comment-form", 'removeClass', array('progress'));
	
	// Return the Ajax Commands Array
	return array('#type' => 'ajax', '#commands' => $commands);
	
}

/**
 * Comments Ajax Callback.
 */
function thechurch_comments_ajax_delete($form, $form_state) {
	
	// Get rid of all of the messages that have been set
	drupal_get_messages();

	// Get the comment & node objects
	$comment = $form['#comment'];
	
	// Put all of the Ajax Commands into an array
	$commands = array();
	
	// FadeOut the deleted comment
	$commands[] = ajax_command_invoke('#comment-'.$comment->cid.' + .comment + .confirmation', 'fadeOut');
		
	// Return the Ajax Commands Array
  return array('#type' => 'ajax', '#commands' => $commands);
	
}

/**
 * Comments Delete Link Ajax Callback.
 */
function thechurch_comments_ajax_confirm_delete_page($cid) {
	
	if ($comment = comment_load($cid)) {

    $form = drupal_get_form('comment_confirm_delete', $comment);
		
    $data = drupal_render($form);
  }
	
	// Put all of the Ajax Commands into an array
	$commands = array();
	
	// Fade out the Comment so the Delete Form can take Precidence
	$commands[] = ajax_command_invoke('#comment-'.$comment->cid.' + .comment', 'hide');
	
	// Append the Delete Form
	$commands[] = ajax_command_after('#comment-'.$comment->cid.' + .comment', $data, array('effect' => 'fade'));
	
	$commands[] = ajax_command_invoke(null, "reAttach", array());
	
	// Mark it as changed
	$commands[] = ajax_command_changed('#comment-'.$cid.' + .comment');
	
	return array('#type' => 'ajax', '#commands' => $commands);
	
}



/**
 * Implementation of hook_menu_alter().
 */
function thechurch_comments_menu_alter(&$items) {

	// Remove access to uneccessary menu itesm
  $items['comment/reply/%node']['access callback'] = false;
  // $items['comment/%/view']['access callback'] = false;
  // $items['comment/%']['access callback'] = false;
  unset($items['comment/%comment/edit']['access callback']);
  $items['comment/%comment/edit']['access arguments'] = array('administer comments');
  
  // Allow users to delete their own comments
  $items['comment/%/delete']['access callback'] = 'thechurch_comments_comment_access';
  $items['comment/%/delete']['access arguments'] = array('edit', 1);
  
  // Set up the Ajax Delivery of Delete Comments Link
  $items['comment/%/delete/ajax'] = $items['comment/%/delete'];
  $items['comment/%/delete/ajax']['delivery callback'] = 'ajax_deliver';
  $items['comment/%/delete/ajax']['page callback'] = 'thechurch_comments_ajax_confirm_delete_page';
  $items['comment/%/delete/ajax']['type'] = MENU_CALLBACK;
  
  // Set up the Ajax Delivery of Delete Comments Link
  $items['node/%node/comments/ajax/%'] = $items['node/%node'];
  $items['node/%node/comments/ajax/%']['delivery callback'] = 'ajax_deliver';
  $items['node/%node/comments/ajax/%']['page callback'] = 'thechurch_comments_comment_node_page_additions';
  $items['node/%node/comments/ajax/%']['type'] = MENU_CALLBACK;
  $items['node/%node/comments/ajax/%']['page arguments'] = array(1,4);

}

/**
 * Determines whether the current user has access to a particular comment.
 *
 * Authenticated users can edit their comments as long they have not been
 * replied to. This prevents people from changing or revising their statements
 * based on the replies to their posts.
 *
 * @param $op
 *   The operation that is to be performed on the comment. Only 'edit' is
 *   recognized now.
 * @param $comment
 *   The comment object.
 * @return
 *   TRUE if the current user has acces to the comment, FALSE otherwise.
 */
function thechurch_comments_comment_access($op, $cid) {

  global $user;
  
  $comment = comment_load($cid);

	
  if ($op == 'edit' && is_object($comment)) {
    return ($user->uid && $user->uid == $comment->uid && $comment->status == COMMENT_PUBLISHED && user_access('edit own comments')) || user_access('administer comments');
  } else {
  	return false;
  }
  
}


/**
 * Build the comment-related elements for node detail pages.
 *
 * @param $node
 *  A node object.
 */
function thechurch_comments_comment_node_page_additions($node, $dir) {
	
  $additions = array();
  global $pager_page_array, $pager_total;

  // Only attempt to render comments if the node has visible comments.
  // Unpublished comments are not included in $node->comment_count, so show
  // comments unconditionally if the user is an administrator.
  if (($node->comment_count && user_access('access comments')) || user_access('administer comments')) {
    $mode = variable_get('comment_default_mode_' . $node->type, COMMENT_MODE_THREADED);
    $comments_per_page = variable_get('comment_default_per_page_' . $node->type, 50);
    if ($cids = comment_get_thread($node, $mode, $comments_per_page)) {
      $comments = comment_load_multiple($cids);
      comment_prepare_thread($comments);
      $build = array();
      if ($dir == 'previous' && $pager_page_array[0] > 0) {
      	$build['pager']['#theme'] = 'thechurch_comments_pager_previous';
      }
      $build['comments'] = comment_view_multiple($comments, $node);
      if ($dir == 'next' && $pager_page_array[0] < $pager_total[0]-1) {
      	$build['pager']['#theme'] = 'thechurch_comments_pager_next';
      }
      $additions['build'] = $build;
    }
  }
    
  // Put all of the Ajax Commands into an array
	$commands = array();
	
	// Add the Comments to the existing list
	// $commands[] = ajax_command_replace('.comment-wrapper .item-list', drupal_render($additions), array('effect' => 'fade'));
	if ($dir == 'next') {
		$commands[] = ajax_command_remove("#node-$node->nid .item-list ul.pager-next");
		$commands[] = ajax_command_append("#node-$node->nid .comment-list", drupal_render($additions), array('effect' => 'fade'));
		if ($build['pager']['#theme'] != 'thechurch_comments_pager_next') {
			$commands[] = ajax_command_remove("#node-$node->nid .new-comment");
		}
	} else {
		$commands[] = ajax_command_remove("#node-$node->nid .item-list ul.pager-previous");
		$commands[] = ajax_command_prepend("#node-$node->nid .comment-list", drupal_render($additions), array('effect' => 'fade'));
	}
	// $commands[] = ajax_command_replace('.comment-wrapper .item-list', '<pre>'.print_r($pager_page_array, true).'</pre>', array('effect' => 'fade'));

		
	return array('#type' => 'ajax', '#commands' => $commands);

}

function theme_thechurch_comments_pager_previous($variables) {
	$dir = $variables['dir'];
	$tags = $variables['tags'];
  $element = 0;
  $parameters = $variables['parameters'];
  $quantity = 0;
  global $pager_page_array, $pager_total;

  // Calculate various markers within this pager piece:
  // Middle is used to "center" pages around the current page.
  $pager_middle = ceil($quantity / 2);
  // current is the page we are currently paged to
  $pager_current = $pager_page_array[$element] + 1;
  // first is the first page listed by this pager piece (re quantity)
  $pager_first = $pager_current - $pager_middle + 1;
  // last is the last page listed by this pager piece (re quantity)
  $pager_last = $pager_current + $quantity - $pager_middle;
  // max is the maximum page number
  $pager_max = $pager_total[$element];
  // End of marker calculations.

  $li_previous = theme('pager_previous', array('text' => (isset($tags[1]) ? $tags[1] : t('‹ previous')), 'element' => $element, 'interval' => 1, 'parameters' => $parameters));

  if ($pager_total[$element] > 1) {

    if ($li_previous) {
      $items[] = array(
        'class' => array('pager-previous'),
        'data' => $li_previous,
      );
    }
    
    return '<h2 class="element-invisible">' . t('Pages') . '</h2>' . theme('item_list', array(
      'items' => $items,
      'attributes' => array('class' => array('pager-previous')),
    ));
  }

}


function theme_thechurch_comments_pager_next($variables) {
	$dir = $variables['dir'];
	$tags = $variables['tags'];
  $element = 0;
  $parameters = $variables['parameters'];
  $quantity = 0;
  global $pager_page_array, $pager_total;

  // Calculate various markers within this pager piece:
  // Middle is used to "center" pages around the current page.
  $pager_middle = ceil($quantity / 2);
  // current is the page we are currently paged to
  $pager_current = $pager_page_array[$element] + 1;
  // first is the first page listed by this pager piece (re quantity)
  $pager_first = $pager_current - $pager_middle + 1;
  // last is the last page listed by this pager piece (re quantity)
  $pager_last = $pager_current + $quantity - $pager_middle;
  // max is the maximum page number
  $pager_max = $pager_total[$element];
  // End of marker calculations.

  $li_next = theme('pager_next', array('text' => (isset($tags[3]) ? $tags[3] : t('next ›')), 'element' => $element, 'interval' => 1, 'parameters' => $parameters));

  if ($pager_total[$element] > 1) {

    if ($li_next) {
      $items[] = array(
        'class' => array('pager-next'),
        'data' => $li_next,
      );
    }
    
    return '<h2 class="element-invisible">' . t('Pages') . '</h2>' . theme('item_list', array(
      'items' => $items,
      'attributes' => array('class' => array('pager-next')),
    ));
  }

}

/**
 * Implements hook_theme().
 */
function thechurch_comments_theme() {
  return array(
    'thechurch_comments_pager_next' => array(),
    'thechurch_comments_pager_previous' => array(),
  );
}
